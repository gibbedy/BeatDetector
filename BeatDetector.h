/*
 * This is my BeatDetector class
 * When combined with the teensy audio libraries FFT object it detects low/med/high frequency beats in audio played.
 * 
 * To use create a BeatDetector object passing it a pointer to an AudioAnalyzeFFT256 object created using the teensy audio library 
 * Once per loop call BeatDetectorLoop().
 * To determine if beat was detected just check objects public variables lowBeat/midBeat/highBeat 
 */
 
 /*
 * BEAT DETECTION ALGORITHYM:
 * A running average of the magnitude of the fft signal is kept for each low/med/high bin range. 
 * The maximum magnitude of fft signal seen in the last second is updated every second (or so)
 * The differnce between average and max audio values is calculated and a beat detection threshold is set between these two values determined by a threshold factor that you can set.
 * If the current audio signal is greater than this threshold then it is a beat.
 * Retriggering of beat detection is locked out for a preset amount of time. (see variables somewhere below)
 * set enableSerialBeatDisplay true and use arduino serial plotter to visualise whats going on.
 *
 * I'm  also experimenting  generating a virtual beat signal. This is generated with bpm timing every time a valid bpm is measured
 * Until a valid bpm is measured, virtualbeat will mirror low beat
 * 
 */
 
#ifndef BEATDETECTOR_H
#define BEATDETECTOR_H

#include <Audio.h>

class BeatDetector 
{
public:
        AudioAnalyzeFFT256 *fft256_1; //pointer to fft object from audio library
        BeatDetector(AudioAnalyzeFFT256&); //constructor takes a refernce to get fft data from audio library 
        bool BeatDetectorLoop(); //method to call in programs loop to perform beat detection

        float lowBeat=0;   // non-zero if low frequency beat was detected after last BeatDetectorLoop was run. value was going to be beat level or something but I haven't done that yet.
        float midBeat=0;   //yada
        float highBeat=0;  //yadaYada
		bool virtualBeat=false; 		         //virtual beat generated by calculating bpm and setting this true 
        bool musicStopped=false;             //if music has changed from paying to stopped this flag is true for one scan
		bool musicPlaying=false;             //True if music has been detected as playing
		bool validBPM=true;					 //true if a valid bpm is currently detected.
		bool fftDataAvailable=false; 		//program that is using beatDetector may want to access raw fft data 
											//so I pass a flag to show when new data is available.
		uint8_t bpm=0; //beats per minute that are detected. I'm thinking of having this info sent to led teensy value of 0 will be used for invalid reading
		bool enableSerialBeatDisplay=false;		//set true to display a graphical view of beat detection when used with arduino serial plotter
		uint32_t fftCount=0; //number of fft samples made in last second
		
private:

bool BeatDetectorUpdate(float &,float &,float &,float &, float * ,int &,const int ,float &, float &, float & ,elapsedMillis &, int &);
elapsedMillis musicPlayingStatusTime = 0;  //music playin status update will be sent a regular intervals below.
const int musicPlayingStatusInterval=5000;  

//I need to determine if music is playing or rather if beats are being detected
//I could do this by listening for a beat and if none heard for a period of:
uint32_t noBeatDuration=3000; 

elapsedMillis beatCountTimer = 0;//timer for above nobeatduration
uint32_t beatCountTime=0;
elapsedMillis virtualBeatTimer=0;  	//time sinnce last virtual beat
uint32_t virtualBeatTime=0;		    //current period of virtual beat
elapsedMillis virtualBeatRetriggerTimer=0;  //timer to lock out double pulses when using virtualBeat
uint32_t virtualBeatRetriggerTime=200;		//minimum time between virtual beats using timer above.
//Then I clear a varialbe to say music is not playing:

bool musicWasPlaying=false;//old status of music used to tell when state changes and updates variable below

//if however a beat is detected I don't want to count 1 lone random noise generated beat as music playing.

//I will do this by incrementing a beatCount variable:
uint32_t beatCount=0;  //(this beatCount variable will be zero'd when above noBeatDuration is reached.
//and checking when it reaches a preset amount:
uint8_t beatsRequired=2;

//I indend to detect the beats per minute of music playing. I will do this by
//1. detecting time between last beat detected using previous beatCountTime variable and adding this to a running list of beat times
const static int BPM_BEAT_LIST_LENGTH=2;   //how many beat times to keep in FILO array. That is how many beat times in a row (plus one because we compare current beat time
                                    //with those in the array) need to be the same before bpm is considered valid.
unsigned int beatTimes[BPM_BEAT_LIST_LENGTH];

//then check if beat times are consistent between beats (in case of list length of 4) 1-2, 2-3, 3-4

const uint8_t BEAT_TOLERANCE=25;  //beat intervals must be between +-10ms to be classed as the same. need to experiment
//and if they all are use that time as accepted  bpm time
//if they are not just ignore bpm calc. only clear current bpm calce when music is seen to stop playing.



//***************************************************************************************************************************************************************
//***************************************************************************************************************************************************************
//variables for BeatDetector low/mid and high
float average=0;
float oldAverage=0;
float averageSmoothing=0.0001;

//global variables required for runFFTLowAverage sequence
 const static int FFTLowAverageNumReadings=115;  //with current fft 115 is aproximately 1 second.This is the amount of samples to find the average signal level I use 115 when I set averageTogether(3) but now I'm using 6 I should set to about half this which 57. Nope now I'm using 3 for averaging.
float FFTLowAverageOldaudioValue=0;
float FFTLowAverageAudioValue=0;
float  FFTLowAverageDValue=0;
float  FFTLowAverageMaxValue=0;                 //the max value seen during last array buffer.
float  FFTLowAverageOldMaxValue=0;
float FFTLowAverageReadings[FFTLowAverageNumReadings]; //the readings from the analog input
int FFTLowAverageReadIndex = 0;                // the index of the current reading
float FFTLowAverageTotal = 0;                  // the running total

float FFTLowAverageThresholdFactor=.7;        //max audio value is multiplied by this to find threshold where signal is seen as a beat (.7 using old way)(1.7 using new way)
float FFTLowAverageSilenceFactor=.75;         //max audio signal seen in the previous number of samples is multiplied by this. if the result is less than the average audio signal then beat detected is ignored (silen vocal bits in song)
int FFTLowAverageRetriggerTime=200;           //time that a new beat detected will be ignored

elapsedMillis FFTLowAverageRetrigger=0;

//global variables required for runFFTMidAverage sequence
const static int FFTMidAverageNumReadings=70;
float FFTMidAverageOldaudioValue=0;
float FFTMidAverageAudioValue=0;
float  FFTMidAverageDValue=0;
float  FFTMidAverageMaxValue=0;                 //the max value seen during last array buffer.
float  FFTMidAverageOldMaxValue=0;
float FFTMidAverageReadings[FFTMidAverageNumReadings];      // the readings from the analog input
int FFTMidAverageReadIndex = 0;              // the index of the current reading
float FFTMidAverageTotal = 0;                  // the running total

//float FFTMidAverageThresholdFactor=0.8;//changed to values below as it totaly doesn't work anymore. not sure what I did.
float FFTMidAverageThresholdFactor=0.4;
float FFTMidAverageSilenceFactor=.75;    
int FFTMidAverageRetriggerTime=100;

elapsedMillis FFTMidAverageRetrigger=0;

//global variables required for runFFTHighAverage sequence
 const static int FFTHighAverageNumReadings=70;
float FFTHighAverageOldaudioValue=0;
float FFTHighAverageAudioValue=0;
float  FFTHighAverageDValue=0;
float  FFTHighAverageMaxValue=0;                 //the max value seen during last array buffer.
float  FFTHighAverageOldMaxValue=0;
float FFTHighAverageReadings[FFTHighAverageNumReadings];      // the readings from the analog input
int FFTHighAverageReadIndex = 0;              // the index of the current reading
float FFTHighAverageTotal = 0;                  // the running total

float FFTHighAverageThresholdFactor=0.07;
float FFTHighAverageSilenceFactor=.5;    
int FFTHighAverageRetriggerTime=150;

elapsedMillis FFTHighAverageRetrigger=0;


//audio analysis data sent over serial to be plotted.
//usefull to tune beat detetion.
//enable none or one of these.
uint32_t serialPlotLow=true;
uint32_t serialPlotMid=false;
uint32_t serialPlotHigh=false;

uint32_t enablePlot=false;      //flag to set/unset when doing beat detection to enable serial plot only for freq range specified in one of the three variables above.
//bools to enable/dissable plotting of beat detection variables to nextion hmi
uint32_t enablePlot0=0;     //first value to plot (selected from checkbox on nextion)
uint32_t enablePlot1=0;
uint32_t enablePlot2=0;
uint32_t enablePlot3=0;



};
#endif //BeatDetector_H
